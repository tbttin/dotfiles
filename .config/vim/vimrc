" options {{{
" Always refer to the relevant :help before adding anything to vimrc.
" Using short names has ONLY cons and ZERO pros.
" TODO Make a teporaryly vimrc file? or a Git branch?

" defaults.vim {{{
" /etc/vimrc
" /usr/share/vim/vimfiles/archlinux.vim
" $VIMDOTDIR/vimrc
" $VIMRUNTIME/defaults.vim
" Load vim's default configs.
unlet! skip_defaults_vim
source $VIMRUNTIME/defaults.vim
" end defaults.vim }}}

" XDG Base Directory Specification {{{
set undodir=$XDG_DATA_HOME/vim/undo     | call mkdir (&g:undodir, 'p', 0700)
set directory=$XDG_DATA_HOME/vim/swap   | call mkdir (&g:directory, 'p', 0700)
set backupdir=$XDG_DATA_HOME/vim/backup | call mkdir (&g:backupdir, 'p', 0700)
set viewdir=$XDG_DATA_HOME/vim/view     | call mkdir (&g:viewdir, 'p', 0700)
set viminfo+=n$XDG_DATA_HOME/vim/viminfo
set runtimepath=$VIMDOTDIR,$VIMRUNTIME,$VIMDOTDIR/after
let &g:packpath=&g:runtimepath
" end XDG }}}

" displays {{{
" Show function name + template in auto completion pop-up menu.
set showfulltag

" When on, splitting a window will put the new window below the current one.
set splitbelow

" Wrap long lines at a character in 'breakat' rather than at the last character.
set linebreak

" Display number and relative number.
set number relativenumber

" Cursor mode indicator.
" TODO Change cursor shape when &term=linux.
let &t_SI .= "\<Esc>[4 q" " SI = INSERT mode.
let &t_SR .= "\<Esc>[4 q" " SR = REPLACE mode.
let &t_EI .= "\<Esc>[2 q" " EI = NORMAL mode (ELSE).
" end displays }}}

" indentations {{{
" Number of spaces to use for each step of (auto)indent.
set shiftwidth=4

" Virtual tab stop (compat for 8-wide tabs).
set softtabstop=4

" Don't use tabs for indentation. Spaces are nicer to work with.
set expandtab
" end indentation }}}

" command-lines {{{
" It's gotta be somewhere in there!
set path=.,,$VIMDOTDIR/**
" end command-line }}}

" Auto save and restore undo history.
set undofile

" Insert two spaces after a '.', '?' and '!' with a join command.
set nojoinspaces

" Disable <Leader> mapping timout.
set notimeout

" Bash default syntax highlighting.
let g:is_bash = 1

" Enable function folding.
"let g:sh_fold_enabled = 1

"" This plugin makes the '%' command jump to matching HTML tags, if/else/endif in Vim scripts, etc.
"if has ('syntax') && has ('eval')
  "packadd! matchit
"endif

" Possibility to have more than one unsaved buffers.
set hidden

" Reset the mouse option was set in defaults.vim.
set mouse&
" end options }}}

" functions {{{
"function! AlignAssignments () " {{{
    " TODO Use this function.
    ""Patterns needed to locate assignment operators...
    "let ASSIGN_OP   = '[-+*/%|&]\?=\@<!=[=~]\@!'
    "let ASSIGN_LINE = '^\(.\{-}\)\s*\(' . ASSIGN_OP . '\)'

    ""Locate block of code to be considered (same indentation, no blanks)
    "let indent_pat = '^' . matchstr(getline('.'), '^\s*') . '\S'
    "let firstline  = search('^\%('. indent_pat . '\)\@!','bnW') + 1
    "let lastline   = search('^\%('. indent_pat . '\)\@!', 'nW') - 1
    "if lastline < 0
        "let lastline = line('$')
    "endif

    ""Find the column at which the operators should be aligned...
    "let max_align_col = 0
    "let max_op_width  = 0
    "for linetext in getline(firstline, lastline)
        ""Does this line have an assignment in it?
        "let left_width = match(linetext, '\s*' . ASSIGN_OP)

        ""If so, track the maximal assignment column and operator width...
        "if left_width >= 0
            "let max_align_col = max([max_align_col, left_width])

            "let op_width      = strlen(matchstr(linetext, ASSIGN_OP))
            "let max_op_width  = max([max_op_width, op_width+1])
        "endif
    "endfor

    ""Code needed to reformat lines so as to align operators...
    "let FORMATTER = '\=printf("%-*s%*s", max_align_col, submatch(1),
                "\                                    max_op_width,  submatch(2))'

    "" Reformat lines with operators aligned in the appropriate column...
    "for linenum in range(firstline, lastline)
        "let oldline = getline(linenum)
        "let newline = substitute(oldline, ASSIGN_LINE, FORMATTER, "")
        "call setline(linenum, newline)
    "endfor
"endfunction " }}}

function! s:IsAdjacentPairs () " {{{
    " TODO Upgrade this function: [\_s*]
    let l:pairs = { '(' : ')', '[' : ']', '{' : '}', '<' : '>', "'" : "'", '"' : '"' }
    let l:mode = mode ()
    if l:mode == 'i' " insert mode.
        let l:open = getline ('.')[col ('.') - 2]
        let l:close = getline ('.')[col ('.') - 1]
    elseif l:mode == 'c' " command line mode.
        let l:open = getcmdline ()[getcmdpos () - 2]
        let l:close = getcmdline ()[getcmdpos () - 1]
    endif
    return get (l:pairs, l:open, 'NONE') == l:close
endfunction " }}}

function! IsMatchOnLHS (pattern) " {{{
    return strpart (getline ('.'), 0, col ('.') - 1) =~ a:pattern
endfunction " }}}

function! s:UpdateTimestamp () " {{{
    let l:line = line ('$') > 10 ? 10 : line ('$')
    kt
    execute 1 . ',' . l:line . 'g/Last modified: /s/Last modified: .*/Last modified: ' .
                \ strftime("%b %d %Y %R %z")
    't
endfunction " }}}

function! s:AddFileDescription () " {{{
    " Search backward after parsing.
    " 0 if not found, no error.
    if search ('\cDescription: .', 'beW')
        if expand ('%:p') =~# '/cforces/'
            execute "normal! iCodeforces problemset \<C-R>=expand ('%:p:h:t')\<CR> - \<Esc>l"
        elseif expand ('%:p') =~# '/cchef/'
            execute "normal! iCodechef practice - \<Esc>l"
        endif
        startinsert
    endif
endfunction " }}}

function! s:ParseTemplate () " {{{
    let l:line = line ('$') > 10 ? 10 : line ('$')
    execute 1 . ',' . l:line . 's/\v\[:VIM_EVAL:\](.{-})\[:END_EVAL:\]/\=eval (submatch (1))/ge'
endfunction " }}}

function! s:LoadTemplate (filename) " {{{
    let l:fullpath = $VIMDOTDIR . '/templates/' . a:filename
    if filereadable (l:fullpath)
        execute '0read ' . l:fullpath
        $delete
        call s:ParseTemplate ()
    endif
endfunction " }}}
" end functions }}}

" mappings {{{
"nmap <silent>  ;=  :call AlignAssignments()<CR>

" [count]{lhs} line comment (without space).
noremap <silent> <Leader>cu :Uncomment<CR>
noremap <silent> <Leader>cc :Comment<CR>
noremap <silent> <Leader>ct :ToggleComment<CR>

" Auto delete adjacent pairs.
noremap! <expr> <BS> <SID>IsAdjacentPairs () ? '<Del><BS>' : '<BS>'

" Pairs auto completions in command line mode.
cnoremap <expr> " getcmdline ()[getcmdpos () - 2] =~ '@' ? '"' : '""<Left>'
cnoremap ' ''<Left>
cnoremap { {}<Left>

" Basic pairs auto completions.
inoremap <expr> " IsMatchOnLHS ('^\s*$') ? '" ' : '""<Left>'
inoremap <expr> ' getline ('.')[col ('.') - 2] =~ '\a' ? "'" : "''<Left>"
noremap! ( ()<Left>
noremap! < <><Left>
noremap! [ []<Left>
inoremap <expr> { IsMatchOnLHS ('^\s*$') ? '{<CR>}<Up><CR>' : '{}<Left>'

" Edit the file under cursor doesn't exist yet.
nnoremap <Leader>gf :tabedit <cfile><CR>

" Tab to complete and literal tab.
inoremap <expr> <Tab> IsMatchOnLHS ('^\s*$') ? '<Tab>' : '<C-N>'
"inoremap <expr> <S-Tab> IsMatchOnLHS ('^\s*$') ? '<S-Tab>' : '<C-P>'
inoremap <S-Tab> <Tab>

" Kill two birds with one stone.
cabbrev H tab help

" Yank from first non-blank to last non-blank.
" TODO How to use register with it?
nnoremap Y ^yg_

" Highlight next/previous line.
xnoremap <Up> <Esc>kV
xnoremap <Down> <Esc>jV

" Search selected text (s register will be used).
xnoremap <Leader>ff "sy/\V<C-R>=escape (@s, '/\')<CR><CR>
" Substitute last search pattern.
" TODO gdefault.
nnoremap <Leader>fs :%substitute///gc<Left><Left><Left>

" Bring me familiar files.
nnoremap <Leader>vv :tabedit $MYVIMRC<CR>
" end mappings }}}

" autocommands {{{
augroup MakePrg " {{{
    autocmd!
    " Use the Makefile template when in practices folder.
    autocmd BufNewFile,BufRead ?*/practices/?*/?*/?*.[ch] setlocal makeprg=make\ -f\ $VIMDOTDIR/templates/Makefile
augroup END " }}}

augroup Templates " {{{
    autocmd!
    " Read and parse templates.
    autocmd BufNewFile ?* call s:LoadTemplate (expand ('<afile>:p:t'))
    " Start insert mode at the end of line containing 'Description: '.
    autocmd BufNewFile main.c call s:AddFileDescription ()
    "autocmd BufWritePre,FileWritePre main.c undojoin | call s:UpdateTimestamp ()
augroup END " }}}
" end autocommands }}}
