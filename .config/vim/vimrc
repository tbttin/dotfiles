" options. {{{
" Always refer to the relevant :help before adding anything to vimrc.
" Using short names has ONLY cons and ZERO pros.

" defaults.vim {{{
" /etc/vimrc
" /usr/share/vim/vimfiles/archlinux.vim
" $VIMDOTDIR/vimrc
" $VIMRUNTIME/defaults.vim
" Load vim's default configs.
unlet! skip_defaults_vim
source $VIMRUNTIME/defaults.vim
" }}}

" Use XDG Base Directory Specification. {{{
set undodir=$XDG_DATA_HOME/vim/undo
set directory=$XDG_DATA_HOME/vim/swap
set backupdir=$XDG_DATA_HOME/vim/backup
set viewdir=$XDG_DATA_HOME/vim/view
set viminfo+=n$XDG_DATA_HOME/vim/viminfo
set runtimepath=$VIMDOTDIR,$VIMRUNTIME,$VIMDOTDIR/after

" If not exist create it.
if !isdirectory (&g:undodir)   | call mkdir (&g:undodir, 'p', 0700)   | endif
if !isdirectory (&g:directory) | call mkdir (&g:directory, 'p', 0700) | endif
if !isdirectory (&g:backupdir) | call mkdir (&g:backupdir, 'p', 0700) | endif
if !isdirectory (&g:viewdir)   | call mkdir (&g:viewdir, 'p', 0700)   | endif
" }}}

" displays. {{{
" Show function name + template in auto completion popup menu.
set showfulltag

" When on, splitting a window will put the new window below the current one.
set splitbelow

" Wrap long lines at a character in 'breakat' rather than at the last character.
set linebreak

" Display number and relative number.
set number relativenumber

" Cursor mode indicator.
" TODO Change cursor shape when &term=linux.
let &t_SI .= "\<Esc>[3 q" " SI = INSERT mode.
let &t_SR .= "\<Esc>[4 q" " SR = REPLACE mode.
let &t_EI .= "\<Esc>[1 q" " EI = NORMAL mode (ELSE).
" }}}

" indentations. {{{
" Number of spaces to use for each step of (auto)indent.
set shiftwidth=4

" Virtual tab stop (compat for 8-wide tabs).
set softtabstop=4

" Don't use tabs for indentation. Spaces are nicer to work with.
set expandtab
" }}}

" command-lines. {{{
" Ignore file pattern in cmdline completion.
" Is that necessary?
"set wildignore+=*.o

" It's gotta be somewhere in there!
set path-=, path+=**
" }}}

" Bash default syntax highlighting.
let g:is_bash = 1
" Enable function folding.
let g:sh_fold_enabled = 1

" This plugin makes the '%' command jump to matching HTML tags, if/else/endif in Vim scripts, etc.
"if has ('syntax') && has ('eval')
"  packadd! matchit
"endif

" Possibility to have more than one unsaved buffers.
set hidden

" Reset defaults.vim mouse option.
set mouse&
" }}}

" functions. {{{
" TODO Fix this, commentstring=/*%s*/ in c, indent, xdefaults, .etc files.
"function! ToggleComment () " {{{
    "if !exists ('b:comment_starter')
        "let b:comment_starter = split (&commentstring, '%s')[0]
    "endif
    "if getline ('.') =~ '^\s*' . b:comment_starter
        "execute ':normal! ^' . len (b:comment_starter) . 'x'
    "else
        "execute ':normal! ^i' . b:comment_starter
    "endif
"endfunction " }}}

function! ToggleComment () range " {{{
    if !exists ('b:comment_starter')
        let b:comment_starter = split (&commentstring, '%s')[0]
    endif
    for l:line in range (a:firstline, a:lastline)
        if getline (l:line) =~ '^\s*' . b:comment_starter
            execute l:line . 'normal! ^d' . len (b:comment_starter) . 'l'
        else
            execute l:line . 'normal! ^i' . b:comment_starter
        endif
    endfor
endfunction " }}}

" TODO Upgrade this function: [\_s*]
function! IsAnAdjacentPairs () " {{{
    let l:pairs = { '(' : ')', '[' : ']', '{' : '}', '<' : '>', "'" : "'", '"' : '"' }
    let l:mode = mode ()
    if l:mode == 'i' " insert mode.
        let l:open = getline ('.')[col ('.') - 2]
        let l:close = getline ('.')[col ('.') - 1]
    elseif l:mode == 'c' " command line mode.
        let l:open = getcmdline ()[getcmdpos () - 2]
        let l:close = getcmdline ()[getcmdpos () - 1]
    endif
    return get (l:pairs, l:open, 'NONE') == l:close
endfunction " }}}

function! AddFileDescription () " {{{
    " Search backward after parsing.
    " 0 if not found, no error.
    if search ('Description: .', 'be')
        if expand ('%:p') =~ '^.*/problemset/.*$'
            execute "normal! iCodeforce problemset \<C-R>=expand ('%:p:h:t')\<CR> - \<Esc>l"
        endif
        startinsert
    endif
endfunction " }}}

function! IsMatchOnLHS (str) " {{{
    return strpart (getline ('.'), 0, col ('.') - 1) =~ a:str
endfunction " }}}
" }}}

" mappings. {{{
" TODO Comment and Uncomment, do we need that?
" Toggle comments.
" command! ToggleComment :call ToggleComment ()
" nnoremap <Leader>c :ToggleComment<CR>
" xnoremap <Leader>c :g/./ToggleComment<CR>
noremap <Leader>c :call ToggleComment ()<CR>

" Auto delete adjacent pairs.
noremap! <expr> <BS> IsAnAdjacentPairs () ? '<Del><BS>' : '<BS>'

" Pairs auto completions in command line mode.
cnoremap " ""<Left>
cnoremap ' ''<Left>
cnoremap ( ()<Left>
cnoremap < <><Left>
cnoremap [ []<Left>
cnoremap { {}<Left>

" Basic pairs auto completions.
inoremap <expr> " IsMatchOnLHS ('^\s*$') ? '"' : '""<Left>'
inoremap <expr> ' getline ('.')[col ('.') - 2] =~ '\a' ? "'" : "''<Left>"
inoremap ( ()<Left>
inoremap < <><Left>
inoremap [ []<Left>
inoremap <expr> { IsMatchOnLHS ('^\s*$') ? '{<CR>}<Up><CR>' : '{}<Left>'

" Edit the file under cursor doesn't exist yet.
nnoremap <Leader>gf :tabedit <cfile><CR>

" Yank to last non-blank.
nnoremap Y yg_

" Tab to complete and literal tab.
inoremap <expr> <Tab> IsMatchOnLHS ('^\s*$') ? '<Tab>' : '<C-N>'
"inoremap <expr> <S-Tab> IsMatchOnLHS ('^\s*$') ? '<S-Tab>' : '<C-P>'
inoremap <S-Tab> <Tab>

" Kill two birds with one stone.
cabbrev H tab help

" Highlight next/previous line.
xnoremap <Up> <Esc>kV
xnoremap <Down> <Esc>jV

" Search selected text.
xnoremap <Leader>ff "sy/\V<C-R>=escape (@s, '/\')<CR><CR>

" Substitute last search pattern.
nnoremap <Leader>fs :%substitute///gc<Left><Left><Left>

" Bring me Makefile template.
nnoremap <Leader>vtM :tabedit $VIMDOTDIR/templates/Makefile<CR>

" Bring me main.c template.
nnoremap <Leader>vtm :tabedit $VIMDOTDIR/templates/main.c<CR>

" Bring me c.vim plugin.
nnoremap <Leader>vc :tabedit $VIMDOTDIR/after/ftplugin/c.vim<CR>

" Bring $MYVIMRC in tab.
nnoremap <Leader>vv :tabedit $MYVIMRC<CR>
" }}}

" autocommands. {{{
augroup FoldMethod
    autocmd!
    " Set foldmethod for vim files.
    autocmd FileType vim set foldmethod=marker
augroup END

augroup MakePrg
    autocmd!
    " Use the Makefile template when in problemset folder.
    autocmd BufNewFile,BufRead */problemset/*/*.c setlocal makeprg=make\ -f\ $VIMDOTDIR/templates/Makefile
augroup END

augroup Templates
    autocmd!
    " TODO Combine these three autocmds?
    " Read in template file with the same name.
    autocmd BufNewFile ?* silent! execute '0read $VIMDOTDIR/templates/' . expand ('<afile>:p:t') | $d
    " Parse special text in the read template.
    autocmd BufNewFile ?* %substitute#\[:VIM_EVAL:\]\(.\{-\}\)\[:END_EVAL:\]#\=eval (submatch (1))#ge
    " Auto start insert mode at the end of line containing 'Description:'.
    autocmd BufNewFile ?* call AddFileDescription ()
augroup END
" }}}
